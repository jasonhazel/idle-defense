<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Idle / Tower Defense Prototype</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>

<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            backgroundColor: '#1a1a1a',
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        let tower, aura, enemies, spawnTimer = 0, hudText, spawnCount = 0, killCount = 0;
        let gameOver = false, gameOverText;
		let baseEnemyHP = 1;
        // Perk multipliers and level-up dialog state
        let auraDamageMult = 1.0;
        let auraSizeMult = 1.0;
        let pickupSizeMult = 1.0;
        let xpGainMult = 1.0;
        let pausedForLevelUp = false;
        let pendingLevelUps = 0;
        let levelDialogBg, levelDialogPanel, levelDialogHeader, levelDialogChoices = [];
		const baseAuraRadius = 80;
		let basePickupRadius = 70; // fixed base, scaled only by pickupSizeMult
        // Survival timer / time-based scaling
        let survivalTimeMs = 0;
        let timeText;
        let lastHpIncBucket = 0; // increments when floor(time/10s) increases
        // XP / Leveling
        let level = 1, xp = 0, xpRequired = 20;
		let xpOrbs, pickupCircle;
		let xpBarBg, xpBarFill, xpBarText, xpBarFullWidth = 0, xpBarHeight = 16;
		let statsText;

        const game = new Phaser.Game(config);

		class Enemy {
			static spawn(scene, x, y, startingHp, onDeath) {
				const circle = scene.add.circle(x, y, 10, 0xff0000);
				scene.physics.add.existing(circle);
				circle.body.setCollideWorldBounds(true);
				circle.maxHealth = startingHp;
				circle.health = circle.maxHealth;
				circle.isDead = false;
				circle.hpText = scene.add.text(circle.x, circle.y, String(Math.ceil(circle.health)), {
					fontFamily: 'monospace',
					fontSize: '12px',
					color: '#ffffff'
				}).setOrigin(0.5).setDepth(5);
				circle.damage = function(amount) {
					if (this.isDead) { return; }
					this.health -= amount;
					if (this.hpText) {
						this.hpText.setText(String(Math.max(0, Math.ceil(this.health))));
					}
					if (this.health <= 0) {
						this.isDead = true;
						try { onDeath && onDeath(this); } catch (e) {}
						if (this.hpText) { this.hpText.destroy(); this.hpText = null; }
						this.destroy();
					}
				};

				return circle;
			}
		}

		class XpOrb {
			static spawn(scene, x, y) {
				const r = Math.random() * 20;
				const theta = Math.random() * Math.PI * 2;
				const ox = Math.cos(theta) * r;
				const oy = Math.sin(theta) * r;
				const orb = scene.add.circle(x + ox, y + oy, 6, 0xffcc00, 0.9);
				orb.setStrokeStyle(1, 0xffffff, 1);
				orb.xpValue = 1;
				// bob/scale juice with auto-stop
				orb.bobTween = scene.tweens.add({ targets: orb, y: orb.y - 6, duration: 600, yoyo: true, repeat: -1, ease: 'sine.inOut' });
				orb.scaleTween = scene.tweens.add({ targets: orb, scale: 1.15, duration: 700, yoyo: true, repeat: -1, ease: 'sine.inOut' });
				scene.time.delayedCall(1000, () => {
					if (orb.bobTween) { orb.bobTween.stop(); orb.bobTween = null; }
					if (orb.scaleTween) { orb.scaleTween.stop(); orb.scaleTween = null; }
				});
				return orb;
			}
		}

        function refreshHud() {
            if (hudText) {
                hudText.setText('Spawned: ' + spawnCount + '   Killed: ' + killCount);
            }
        }

        function preload() { }

        function create() {
            // tower in the center
            tower = this.add.circle(400, 300, 20, 0x00ff00);
            this.physics.add.existing(tower);
            tower.body.setImmovable(true);
            // tower health
            tower.maxHealth = 100;
            tower.health = tower.maxHealth;
            tower.hpText = this.add.text(tower.x, tower.y, String(tower.health), {
                fontFamily: 'monospace',
                fontSize: '14px',
                color: '#000000'
            }).setOrigin(0.5).setDepth(10);

            enemies = this.physics.add.group();
            xpOrbs = this.add.group();

            // tower aura visual (small circle around tower)
            const auraRadius = baseAuraRadius * auraSizeMult;
            aura = this.add.circle(tower.x, tower.y, auraRadius, 0x00ff00, 0.12);
            aura.setStrokeStyle(2, 0x00ff00, 0.6);
            this.physics.add.existing(aura);
            aura.body.setCircle(auraRadius);
            aura.body.setImmovable(true);
            aura.body.setAllowGravity(false);
            aura.body.moves = false;

            // We no longer insta-kill on touching tower; aura will deal damage over time

		// pickup circle (independent of aura size)
		const pickupRadius = basePickupRadius * pickupSizeMult;
            pickupCircle = this.add.circle(tower.x, tower.y, pickupRadius, 0x3399ff, 0.08);
            pickupCircle.setStrokeStyle(1, 0x3399ff, 0.4);

            // HUD counters
            hudText = this.add.text(10, 10, 'Spawned: 0   Killed: 0', {
                fontFamily: 'monospace',
                fontSize: '16px',
                color: '#ffffff'
            });

		// Survival timer in top-right
            timeText = this.add.text(this.scale.width - 10, 10, '00:00', {
                fontFamily: 'monospace',
                fontSize: '16px',
                color: '#ffffff',
                align: 'right'
            }).setOrigin(1, 0);

		// Stats panel (right side under timer)
		statsText = this.add.text(this.scale.width - 10, 32, '', {
			fontFamily: 'monospace',
			fontSize: '12px',
			color: '#cccccc',
			align: 'right'
		}).setOrigin(1, 0);

            // XP progress bar UI at bottom
            const margin = 20;
            const barY = this.scale.height - margin;
            xpBarFullWidth = this.scale.width - (margin * 2);
            xpBarBg = this.add.rectangle(margin, barY, xpBarFullWidth, xpBarHeight, 0x333333).setOrigin(0, 0.5);
            xpBarFill = this.add.rectangle(margin, barY, xpBarFullWidth, xpBarHeight, 0x88ff88).setOrigin(0, 0.5);
            xpBarFill.setDisplaySize(0, xpBarHeight);
            xpBarText = this.add.text(margin, barY - 24, '', {
                fontFamily: 'monospace',
                fontSize: '14px',
                color: '#ffffff'
            }).setOrigin(0, 0.5);
            refreshXpUi();

            // Per-tick tower contact damage handled in update()
        }

        function spawnEnemy(scene) {
            // random edge spawn
            const side = Phaser.Math.Between(0, 3);
            let x, y;
            if (side === 0) { x = 0; y = Phaser.Math.Between(0, 600); }
            else if (side === 1) { x = 800; y = Phaser.Math.Between(0, 600); }
            else if (side === 2) { x = Phaser.Math.Between(0, 800); y = 0; }
            else { x = Phaser.Math.Between(0, 800); y = 600; }

            const enemy = Enemy.spawn(scene, x, y, baseEnemyHP, (deadEnemy) => {
                killCount++;
                // spawn XP orb (value 1)
                spawnXpOrb(scene, deadEnemy.x, deadEnemy.y);
                refreshHud();
            });
            enemies.add(enemy);
            spawnCount++;
            refreshHud();
        }

        function update(time, delta) {
            spawnTimer += delta;
		if (!gameOver && !pausedForLevelUp) {
                // update survival timer
                survivalTimeMs += delta;
                const totalSeconds = Math.floor(survivalTimeMs / 1000);
                const mm = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
                const ss = String(totalSeconds % 60).padStart(2, '0');
                if (timeText) { timeText.setText(mm + ':' + ss); }

                // time-based enemy HP scaling: +1 every 10 seconds
                const bucket = Math.floor(totalSeconds / 10);
                if (bucket > lastHpIncBucket) {
                    baseEnemyHP += (bucket - lastHpIncBucket);
                    lastHpIncBucket = bucket;
		}

		// update stats panel each frame
		refreshStatsUi();
            }
            if (!gameOver && !pausedForLevelUp && spawnTimer > 1000) { // spawn every 1 s
                spawnEnemy(this);
                spawnTimer = 0;
            }

            enemies.getChildren().forEach(e => {
                if (!gameOver && !pausedForLevelUp) {
                const angle = Phaser.Math.Angle.Between(e.x, e.y, 400, 300);
                const speed = 60;
                e.body.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
                } else {
                    if (e && e.body) { e.body.setVelocity(0, 0); }
                }
                if (e.hpText) { e.hpText.setPosition(e.x, e.y); }
            });

		// keep tower HP text and pickup circle centered on tower (in case we animate/move tower later)
            if (tower && tower.hpText) {
                tower.hpText.setPosition(tower.x, tower.y);
            }
            if (pickupCircle) {
                pickupCircle.setPosition(tower.x, tower.y);
            }

            // tower contact damage over time (enemies adjacent to tower)
            if (!gameOver && !pausedForLevelUp) {
                let totalContactDps = 0;
                const towerRadius = (tower && typeof tower.radius === 'number') ? tower.radius : 20;
                enemies.getChildren().forEach(e => {
                    const enemyRadius = (typeof e.radius === 'number') ? e.radius : 10;
                    const dx = e.x - tower.x;
                    const dy = e.y - tower.y;
                    const contactDist = towerRadius + enemyRadius;
                    if ((dx * dx + dy * dy) <= contactDist * contactDist) {
                        totalContactDps += Math.max(0, e.maxHealth || 0);
                    }
                });
                if (totalContactDps > 0) {
                    const contactDamageThisTick = (totalContactDps * delta) / 1000;
                    tower.health = Math.max(0, tower.health - contactDamageThisTick);
                    if (tower.hpText) { tower.hpText.setText(String(Math.ceil(tower.health))); }
                    if (tower.health <= 0 && !gameOver) {
                        gameOver = true;
                        gameOverText = this.add.text(400, 300, 'GAME OVER', {
                            fontFamily: 'monospace',
                            fontSize: '32px',
                            color: '#ff5555'
                        }).setOrigin(0.5).setDepth(200);
                        enemies.getChildren().forEach(e => { if (e && e.body) { e.body.setVelocity(0, 0); } });
                    }
                }
            }

            // aura damage over time (disabled when game over)
            if (!gameOver && !pausedForLevelUp) {
                const damagePerSecond = 10 * auraDamageMult; // scaled aura DPS
                const damageThisTick = (damagePerSecond * delta) / 1000;
                if (aura) {
                    const effectiveAuraRadius = baseAuraRadius * auraSizeMult;
                    enemies.getChildren().forEach(e => {
                        // check distance to tower center for aura radius
                        const dx = e.x - tower.x;
                        const dy = e.y - tower.y;
                        const distSq = dx * dx + dy * dy;
                        if (distSq <= effectiveAuraRadius * effectiveAuraRadius) {
                            if (typeof e.damage === 'function') {
                                e.damage(damageThisTick);
                            }
                        }
                    });
                }
            }

            // collect XP orbs when inside pickup circle
            if (!gameOver && !pausedForLevelUp && pickupCircle && xpOrbs) {
                let gained = 0;
                xpOrbs.getChildren().slice().forEach(orb => {
                    const dx = orb.x - tower.x;
                    const dy = orb.y - tower.y;
			const effectivePickupRadius = basePickupRadius * pickupSizeMult;
                    if ((dx * dx + dy * dy) <= (effectivePickupRadius * effectivePickupRadius)) {
                        gained += (orb.xpValue || 1);
                        spawnSparkle(this, orb.x, orb.y);
                        orb.destroy();
                        xpOrbs.remove(orb, true, true);
                    }
                });
                if (gained > 0) {
                    xp += gained * xpGainMult;
                    // level up while enough XP
                    while (xp >= xpRequired) {
                        xp -= xpRequired;
                        level += 1;
                        xpRequired = Math.ceil(xpRequired * 1.5);
                        queueLevelUp(this);
                    }
                    refreshXpUi();
                }
            }
        }

        function refreshRadii() {
            // Aura scales with auraSizeMult; pickup uses independent basePickupRadius
            if (aura) {
                const newAuraRadius = baseAuraRadius * auraSizeMult;
                aura.setRadius(newAuraRadius);
            }
            if (pickupCircle) {
                const newPickup = basePickupRadius * pickupSizeMult;
                pickupCircle.setRadius(newPickup);
            }
            refreshStatsUi();
        }

        function queueLevelUp(scene) {
            pendingLevelUps += 1;
            if (!pausedForLevelUp) {
                openLevelUpDialog(scene);
            }
        }

        function openLevelUpDialog(scene) {
            pausedForLevelUp = true;
            // overlay and panel
            levelDialogBg = scene.add.rectangle(scene.scale.width / 2, scene.scale.height / 2, scene.scale.width, scene.scale.height, 0x000000, 0.6).setDepth(500);
            levelDialogPanel = scene.add.rectangle(scene.scale.width / 2, scene.scale.height / 2, 520, 220, 0x222222, 0.95).setStrokeStyle(2, 0xffffff, 0.8).setDepth(501);
            levelDialogHeader = scene.add.text(scene.scale.width / 2, scene.scale.height / 2 - 80, 'Level Up! Choose a perk', {
                fontFamily: 'monospace', fontSize: '18px', color: '#ffffff'
            }).setOrigin(0.5).setDepth(502);

            const allPerks = [
                { key: 'aura_dmg', label: 'Increase aura damage (+25%)' },
                { key: 'aura_size', label: 'Increase aura size (+25%)' },
                { key: 'pickup_size', label: 'Increase pickup size (+25%)' },
                { key: 'tower_health', label: 'Increase tower health (+25%)' },
                { key: 'xp_gain', label: 'Increase XP gain (+25%)' },
            ];
            const choices = sampleThree(allPerks);

            levelDialogChoices = choices.map((perk, idx) => {
                const y = scene.scale.height / 2 - 20 + idx * 50;
                const choiceBg = scene.add.rectangle(scene.scale.width / 2, y, 480, 38, 0x444444, 0.9).setStrokeStyle(1, 0xffffff, 0.5).setDepth(501).setInteractive({ useHandCursor: true });
                const txt = scene.add.text(scene.scale.width / 2, y, perk.label, { fontFamily: 'monospace', fontSize: '16px', color: '#ffffff' }).setOrigin(0.5).setDepth(502);
                choiceBg.on('pointerdown', () => {
                    applyPerk(perk.key);
                    closeLevelUpDialog();
                    pendingLevelUps -= 1;
                    if (pendingLevelUps > 0) {
                        openLevelUpDialog(scene);
                    } else {
                        pausedForLevelUp = false;
                    }
                });
                return [choiceBg, txt];
            });
        }

        function closeLevelUpDialog() {
            if (levelDialogBg) { levelDialogBg.destroy(); levelDialogBg = null; }
            if (levelDialogPanel) { levelDialogPanel.destroy(); levelDialogPanel = null; }
            if (levelDialogHeader) { levelDialogHeader.destroy(); levelDialogHeader = null; }
            levelDialogChoices.forEach(pair => { pair[0].destroy(); pair[1].destroy(); });
            levelDialogChoices = [];
        }

        function applyPerk(key) {
            switch (key) {
                case 'aura_dmg':
                    auraDamageMult *= 1.25;
                    break;
                case 'aura_size':
                    auraSizeMult *= 1.25;
                    refreshRadii();
                    break;
                case 'pickup_size':
                    pickupSizeMult *= 1.25;
                    refreshRadii();
                    break;
                case 'tower_health': {
                    const newMax = Math.ceil(tower.maxHealth * 1.25);
                    const newHealth = Math.min(newMax, Math.ceil(tower.health * 1.25));
                    tower.maxHealth = newMax;
                    tower.health = newHealth;
                    if (tower.hpText) { tower.hpText.setText(String(Math.ceil(tower.health))); }
                    break;
                }
                case 'xp_gain':
                    xpGainMult *= 1.25;
                    break;
            }
        }

        function sampleThree(arr) {
            const idxs = [];
            while (idxs.length < 3) {
                const i = Math.floor(Math.random() * arr.length);
                if (!idxs.includes(i)) idxs.push(i);
            }
            return idxs.map(i => arr[i]);
        }

        function refreshXpUi() {
            if (!xpBarFill || !xpBarText) { return; }
            const progress = Math.max(0, Math.min(1, xpRequired > 0 ? (xp / xpRequired) : 0));
            xpBarFill.setDisplaySize(xpBarFullWidth * progress, xpBarHeight);
            xpBarText.setText('Level ' + level + '   XP: ' + Math.floor(xp) + ' / ' + xpRequired);
        }

        function refreshStatsUi() {
            if (!statsText) { return; }
            const lines = [
                'Aura Dmg: x' + auraDamageMult.toFixed(2),
                'Aura Size: x' + auraSizeMult.toFixed(2),
                'Pickup Size: x' + pickupSizeMult.toFixed(2),
                'XP Gain: x' + xpGainMult.toFixed(2)
            ];
            statsText.setText(lines.join('\n'));
        }

        function spawnXpOrb(scene, x, y) {
            const orb = XpOrb.spawn(scene, x, y);
            xpOrbs.add(orb);
        }

        function spawnSparkle(scene, x, y) {
            // create a small burst of mini-circles that expand and fade
            const particles = [];
            const count = 8;
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const px = x + Math.cos(angle) * 2;
                const py = y + Math.sin(angle) * 2;
                const p = scene.add.circle(px, py, 2, 0xffffff, 1).setDepth(300);
                particles.push(p);
                scene.tweens.add({
                    targets: p,
                    x: x + Math.cos(angle) * 10,
                    y: y + Math.sin(angle) * 10,
                    scale: 0.2,
                    alpha: 0,
                    duration: 250,
                    ease: 'sine.out',
                    onComplete: () => p.destroy()
                });
            }
        }
    </script>
</body>

</html>